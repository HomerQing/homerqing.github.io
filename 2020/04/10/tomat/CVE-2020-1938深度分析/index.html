<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="本文涉及的Tomcat环境为Tomcat&#x2F;8.5.19 Tomcat初始化过程本章节将详细介绍Tomcat处理AJP请求的流程，以及用于处理AJP请求的关键部分Connector的初始化过程，阅读本章节有助于理解Tomcat处理AJP请求的过程，如只需了解漏洞的利用原理也可直接跳到第二章节。 Connector的初始化流程Connector作为Server(Apache)和Container(Se">
<meta property="og:type" content="article">
<meta property="og:title" content="tomat&#x2F;CVE-2020-1938深度分析">
<meta property="og:url" content="http://homerqing.github.io/2020/04/10/tomat/CVE-2020-1938%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90/index.html">
<meta property="og:site_name" content="Homer&#39;s blog">
<meta property="og:description" content="本文涉及的Tomcat环境为Tomcat&#x2F;8.5.19 Tomcat初始化过程本章节将详细介绍Tomcat处理AJP请求的流程，以及用于处理AJP请求的关键部分Connector的初始化过程，阅读本章节有助于理解Tomcat处理AJP请求的过程，如只需了解漏洞的利用原理也可直接跳到第二章节。 Connector的初始化流程Connector作为Server(Apache)和Container(Se">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://note.youdao.com/yws/res/2325/271F9B9B5D2B403EA3D71F541095CD96">
<meta property="og:image" content="https://note.youdao.com/yws/res/2547/D451A0EF9BFA49F5922031F07873822C">
<meta property="og:image" content="https://note.youdao.com/yws/res/2725/D7364EE348FA43FBA5651C00DF553FAE">
<meta property="og:image" content="https://note.youdao.com/yws/res/3121/B504C16A52D74EE0A042541356EBED0B">
<meta property="og:image" content="https://note.youdao.com/yws/res/3173/C641462F5FA845E99A21B68B9D5921CD">
<meta property="article:published_time" content="2020-04-10T15:28:24.727Z">
<meta property="article:modified_time" content="2020-04-10T15:28:24.727Z">
<meta property="article:author" content="Homer">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://note.youdao.com/yws/res/2325/271F9B9B5D2B403EA3D71F541095CD96">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>tomat/CVE-2020-1938深度分析</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- rss -->
    
    
<meta name="generator" content="Hexo 4.2.0"></head>

<body>
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/posts/">Writing</a></li>
         
          <li><a href="http://github.com/sergodeeva" target="_blank" rel="noopener">Projects</a></li>
         
          <li><a href="/URL">LINK_NAME</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        
        <li><a class="icon" href="/2020/04/10/fastjson/fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E9%98%B2%E5%BE%A1%E5%92%8C%E7%BB%95%E8%BF%87/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://homerqing.github.io/2020/04/10/tomat/CVE-2020-1938%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90/" target="_blank" rel="noopener"><i class="fa fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://homerqing.github.io/2020/04/10/tomat/CVE-2020-1938%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90/&text=tomat/CVE-2020-1938深度分析" target="_blank" rel="noopener"><i class="fa fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://homerqing.github.io/2020/04/10/tomat/CVE-2020-1938%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90/&title=tomat/CVE-2020-1938深度分析" target="_blank" rel="noopener"><i class="fa fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://homerqing.github.io/2020/04/10/tomat/CVE-2020-1938%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90/&is_video=false&description=tomat/CVE-2020-1938深度分析" target="_blank" rel="noopener"><i class="fa fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=tomat/CVE-2020-1938深度分析&body=Check out this article: http://homerqing.github.io/2020/04/10/tomat/CVE-2020-1938%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90/"><i class="fa fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://homerqing.github.io/2020/04/10/tomat/CVE-2020-1938%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90/&title=tomat/CVE-2020-1938深度分析" target="_blank" rel="noopener"><i class="fa fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://homerqing.github.io/2020/04/10/tomat/CVE-2020-1938%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90/&title=tomat/CVE-2020-1938深度分析" target="_blank" rel="noopener"><i class="fa fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://homerqing.github.io/2020/04/10/tomat/CVE-2020-1938%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90/&title=tomat/CVE-2020-1938深度分析" target="_blank" rel="noopener"><i class="fa fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://homerqing.github.io/2020/04/10/tomat/CVE-2020-1938%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90/&title=tomat/CVE-2020-1938深度分析" target="_blank" rel="noopener"><i class="fa fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://homerqing.github.io/2020/04/10/tomat/CVE-2020-1938%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90/&name=tomat/CVE-2020-1938深度分析&description=" target="_blank" rel="noopener"><i class="fa fa-tumblr " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Tomcat初始化过程"><span class="toc-number">1.</span> <span class="toc-text">Tomcat初始化过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Connector的初始化流程"><span class="toc-number">1.1.</span> <span class="toc-text">Connector的初始化流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DEBUG-CVE-2020-1938"><span class="toc-number">2.</span> <span class="toc-text">DEBUG CVE-2020-1938</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-number">3.</span> <span class="toc-text">参考</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index width mx-auto px2 my4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        tomat/CVE-2020-1938深度分析
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">Homer's blog</span>
      </span>
      
    <div class="postdate">
        <time datetime="2020-04-10T15:28:24.727Z" itemprop="datePublished">2020-04-10</time>
    </div>


      

    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <p>本文涉及的Tomcat环境为Tomcat/8.5.19</p>
<h2 id="Tomcat初始化过程"><a href="#Tomcat初始化过程" class="headerlink" title="Tomcat初始化过程"></a>Tomcat初始化过程</h2><p>本章节将详细介绍Tomcat处理AJP请求的流程，以及用于处理AJP请求的关键部分Connector的初始化过程，阅读本章节有助于理解Tomcat处理AJP请求的过程，如只需了解漏洞的利用原理也可直接跳到第二章节。</p>
<h3 id="Connector的初始化流程"><a href="#Connector的初始化流程" class="headerlink" title="Connector的初始化流程"></a>Connector的初始化流程</h3><p>Connector作为Server(Apache)和Container(Servlet)之间的消息传递者，通过指定的协议和接口来监听Server的请求，在对请求进行必要的处理和解析后将请求的内容传递给对应的Containe，经Containe一层层的处理后，生成最终的响应信息，返回给Server。 </p>
<p>Connector使用<code>ProtocolHandler</code>来处理请求，并根据携带请求的协议类型对应到各自的<code>ProtocolHandler</code>，如对应AJP协议的：</p>
<ul>
<li><code>AjpNioProtocol</code>   </li>
<li><code>AjpAprProtocol</code>  </li>
</ul>
<p>ProtocolHandler有三个非常重要的组件：Endpoint,Processor和Adapter。  </p>
<ul>
<li><code>Endpoint</code>: 用于处理底层Socket的网络协议。 Endpoint的抽象实现类AbstractEndpoint中定义了Acceptor,AsyncTimeout两个内部类和一个接口Handler<ul>
<li><code>Acceptor</code>: 用于监听请求。</li>
<li><code>AsyncTimeout</code>: 用于异步检查request超时。</li>
<li><code>Handler</code>: 用于处理接收到的Socket,在内部调用了Processor</li>
</ul>
</li>
<li><code>Processor</code>: 用于将Endpoint接收到的Socket封装成Request</li>
<li><code>Adapter</code>: 用于将封装好的Request交给Containner进行具体处理。  </li>
</ul>
<p>Connector处理请求过程如下图:<br>（图片引用自参考1）<br><img src="https://note.youdao.com/yws/res/2325/271F9B9B5D2B403EA3D71F541095CD96" alt="image"></p>
<p>Tomcat启动时会初始化server.xml中定义的所有Connector，默认存在两个Connector，分别是HTTP和AJP，server.xml中的相关配置如下：  </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Service</span> <span class="attr">name</span>=<span class="string">"Catalina"</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8080"</span> <span class="attr">protocol</span>=<span class="string">"HTTP/1.1"</span> <span class="attr">connectionTimeout</span>=<span class="string">"20000"</span> <span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8009"</span> <span class="attr">protocol</span>=<span class="string">"AJP/1.3"</span> <span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Service</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Http Connector, 基于 HTTP 协议，负责建立 HTTP 连接。它又分为 BIO Http Connector 与 NIO Http Connector 两种，后者提供非阻塞 IO 与长连接 Comet 支持。  </li>
<li>AJP Connector, 基于 AJP 协议，AJP 是专门设计用来为 tomcat 与 http 服务器之间通信专门定制的协议，能提供较高的通信速度和效率。如与 Apache 服务器集成时，采用这个协议。</li>
</ul>
<p>Connector的初始化是在<code>org.apache.catalina.startup.Catalina</code>的load方法中，执行createStartDigester()解析server.xml配置文件的配置信息所创建的。   </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.apache.catalina.startup.Catalina::createStartDigester</span></span><br><span class="line">digester.addRule(<span class="string">"Server/Service/Connector"</span>, <span class="keyword">new</span> ConnectorCreateRule());</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.apache.catalina.startup.ConnectorCreateRule::begin</span></span><br><span class="line">Connector con = <span class="keyword">new</span> Connector(attributes.getValue(<span class="string">"protocol"</span>));</span><br></pre></td></tr></table></figure>
<p>可见Connector的创建流程最终执行到了<code>org.apache.catalina.Connector</code>的构造函数中，下面贴出Connector中的几个关键方法：  </p>
<ol>
<li>在Connector的构造函数中，将server.xml中Connector的protocol “HTTP/1.1”，”AJP/1.3” 转换为ProtocolHandler：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.apache.catalina.Connector</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Connector</span><span class="params">(String protocol)</span> </span>&#123;</span><br><span class="line">	  <span class="comment">// 将server.xml中配置的protocol “HTTP/1.1”，“AJP/1.3” 转换为上文中的6种protocol;  </span></span><br><span class="line">      setProtocol(protocol);</span><br><span class="line">      Class&lt;?&gt; clazz = Class.forName(protocolHandlerClassName);</span><br><span class="line">		</span><br><span class="line">	  <span class="comment">//调用具体protocol的无参构造函数，实例化。</span></span><br><span class="line">      <span class="keyword">this</span>.protocolHandler = (ProtocolHandler) clazz.newInstance();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>在setPortocal中指定ProtocolHandler类型，如protocol为AJP且没有定义aprConnector，将使用<code>org.apache.coyote.ajp.AjpNioProtocol</code>。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProtocol</span><span class="params">(String protocol)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> aprConnector = AprLifecycleListener.isAprAvailable() &amp;&amp;</span><br><span class="line">            AprLifecycleListener.getUseAprConnector();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"HTTP/1.1"</span>.equals(protocol) || protocol == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (aprConnector) &#123;</span><br><span class="line">            setProtocolHandlerClassName(<span class="string">"org.apache.coyote.http11.Http11AprProtocol"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            setProtocolHandlerClassName(<span class="string">"org.apache.coyote.http11.Http11NioProtocol"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//创建AJP的ProtocolHandler</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"AJP/1.3"</span>.equals(protocol)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (aprConnector) &#123;</span><br><span class="line">            setProtocolHandlerClassName(<span class="string">"org.apache.coyote.ajp.AjpAprProtocol"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            setProtocolHandlerClassName(<span class="string">"org.apache.coyote.ajp.AjpNioProtocol"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        setProtocolHandlerClassName(protocol);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
在<code>org.apache.coyote.ajp.AjpNioProtocol</code>中，设置了NioEndpoint类型的endpoint，以及AjpProtocol的Handler，关键代码如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.coyote.ajp.AjpNioProtocol</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AjpNioProtocol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="keyword">new</span> NioEndpoint());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.coyote.ajp.AbstractAjpProtocol</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AbstractAjpProtocol</span><span class="params">(AbstractEndpoint&lt;S&gt; endpoint)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(endpoint);</span><br><span class="line">        setConnectionTimeout(Constants.DEFAULT_CONNECTION_TIMEOUT);</span><br><span class="line">        <span class="comment">// AJP does not use Send File</span></span><br><span class="line">        getEndpoint().setUseSendfile(<span class="keyword">false</span>);</span><br><span class="line">        ConnectionHandler&lt;S&gt; cHandler = <span class="keyword">new</span> ConnectionHandler&lt;&gt;(<span class="keyword">this</span>);</span><br><span class="line">        setHandler(cHandler);</span><br><span class="line">        getEndpoint().setHandler(cHandler);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.coyote.AbstractProtocol</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AbstractProtocol</span><span class="params">(AbstractEndpoint&lt;S&gt; endpoint)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.endpoint = endpoint;</span><br><span class="line">        setSoLinger(Constants.DEFAULT_CONNECTION_LINGER);</span><br><span class="line">        setTcpNoDelay(Constants.DEFAULT_TCP_NO_DELAY);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li>初始化Connector和protocolHandler<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.apache.catalina.Connector</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">super</span>.initInternal();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化adapter并将adapter设置到protocolHandler中</span></span><br><span class="line">        adapter = <span class="keyword">new</span> CoyoteAdapter(<span class="keyword">this</span>);</span><br><span class="line">        protocolHandler.setAdapter(adapter);</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 初始化protocolHandler</span></span><br><span class="line">            protocolHandler.init();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> LifecycleException(</span><br><span class="line">                    sm.getString(<span class="string">"coyoteConnector.protocolHandlerInitializationFailed"</span>), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="DEBUG-CVE-2020-1938"><a href="#DEBUG-CVE-2020-1938" class="headerlink" title="DEBUG CVE-2020-1938"></a>DEBUG CVE-2020-1938</h2><p>到这里为止Connector已经初始化完成，启动过程不再详述。在开始调用栈分析前先总结一下上文要点：</p>
<ol>
<li>Tomcat中的Connector用于Server和Container之间的消息传递；</li>
<li>Connector会对不同的协议分配ProtocolHandler，用于该协议生命周期的管理。</li>
</ol>
<p>先看调用栈  </p>
<ul>
<li>任意文件读取调用栈：  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">serveResource:780, DefaultServlet (org.apache.catalina.servlets)</span><br><span class="line">doGet:461, DefaultServlet (org.apache.catalina.servlets)</span><br><span class="line">service:635, HttpServlet (javax.servlet.http)</span><br><span class="line">service:441, DefaultServlet (org.apache.catalina.servlets)</span><br><span class="line">service:742, HttpServlet (javax.servlet.http)</span><br><span class="line">internalDoFilter:231, ApplicationFilterChain (org.apache.catalina.core)</span><br><span class="line">doFilter:166, ApplicationFilterChain (org.apache.catalina.core)</span><br><span class="line">doFilter:52, WsFilter (org.apache.tomcat.websocket.server)</span><br><span class="line">internalDoFilter:193, ApplicationFilterChain (org.apache.catalina.core)</span><br><span class="line">doFilter:166, ApplicationFilterChain (org.apache.catalina.core)</span><br><span class="line">invoke:199, StandardWrapperValve (org.apache.catalina.core)</span><br><span class="line">invoke:96, StandardContextValve (org.apache.catalina.core)</span><br><span class="line">invoke:140, StandardHostValve (org.apache.catalina.core)</span><br><span class="line">invoke:80, ErrorReportValve (org.apache.catalina.valves)</span><br><span class="line">invoke:639, AbstractAccessLogValve (org.apache.catalina.valves)</span><br><span class="line">invoke:87, StandardEngineValve (org.apache.catalina.core)</span><br><span class="line">service:342, CoyoteAdapter (org.apache.catalina.connector)</span><br><span class="line">service:486, AjpProcessor (org.apache.coyote.ajp)</span><br><span class="line">process:66, AbstractProcessorLight (org.apache.coyote)</span><br><span class="line">process:868, AbstractProtocol$ConnectionHandler (org.apache.coyote)</span><br><span class="line">doRun:1455, NioEndpoint$SocketProcessor (org.apache.tomcat.util.net)</span><br><span class="line">run:49, SocketProcessorBase (org.apache.tomcat.util.net)</span><br><span class="line">runWorker:1149, ThreadPoolExecutor (java.util.concurrent)</span><br><span class="line">run:624, ThreadPoolExecutor$Worker (java.util.concurrent)</span><br><span class="line">run:61, TaskThread$WrappingRunnable (org.apache.tomcat.util.threads)</span><br><span class="line">run:748, Thread (java.lang)</span><br><span class="line">&#96;&#96;&#96;   </span><br><span class="line"></span><br><span class="line">- 远程文件包含调用栈：</span><br></pre></td></tr></table></figure>
compile:593, JspCompilationContext (org.apache.jasper)<br>service:368, JspServletWrapper (org.apache.jasper.servlet)<br>serviceJspFile:385, JspServlet (org.apache.jasper.servlet)<br>service:329, JspServlet (org.apache.jasper.servlet)<br>service:742, HttpServlet (javax.servlet.http)<br>internalDoFilter:231, ApplicationFilterChain (org.apache.catalina.core)<br>doFilter:166, ApplicationFilterChain (org.apache.catalina.core)<br>doFilter:52, WsFilter (org.apache.tomcat.websocket.server)<br>internalDoFilter:193, ApplicationFilterChain (org.apache.catalina.core)<br>doFilter:166, ApplicationFilterChain (org.apache.catalina.core)<br>invoke:199, StandardWrapperValve (org.apache.catalina.core)<br>invoke:96, StandardContextValve (org.apache.catalina.core)<br>invoke:140, StandardHostValve (org.apache.catalina.core)<br>invoke:80, ErrorReportValve (org.apache.catalina.valves)<br>invoke:639, AbstractAccessLogValve (org.apache.catalina.valves)<br>invoke:87, StandardEngineValve (org.apache.catalina.core)<br>service:342, CoyoteAdapter (org.apache.catalina.connector)<br>service:486, AjpProcessor (org.apache.coyote.ajp)<br>process:66, AbstractProcessorLight (org.apache.coyote)<br>process:868, AbstractProtocol$ConnectionHandler (org.apache.coyote)<br>doRun:1455, NioEndpoint$SocketProcessor (org.apache.tomcat.util.net)<br>run:49, SocketProcessorBase (org.apache.tomcat.util.net)<br>runWorker:1149, ThreadPoolExecutor (java.util.concurrent)<br>run:624, ThreadPoolExecutor$Worker (java.util.concurrent)<br>run:61, TaskThread$WrappingRunnable (org.apache.tomcat.util.threads)<br>run:748, Thread (java.lang)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">可以看到两者的调用栈在&#96;service:742, HttpServlet (javax.servlet.http)&#96;这里以及之前都是相同的，Tomcat对于jsp文件会单独使用JspServlet进行处理并编译。  </span><br><span class="line"></span><br><span class="line">下文将对两个调用栈进行完整的分析。  </span><br><span class="line"></span><br><span class="line">首先Tomcat从&#96;doRun:1455, NioEndpoint$SocketProcessor (org.apache.tomcat.util.net)&#96;这里开始监听Server的request并进行后续处理。下文继续详述Tomcat处理request的过程以及对AJP协议数据的处理。</span><br><span class="line">### Tomcat对AJP协议请求的处理过程以及漏洞成因</span><br><span class="line"></span><br><span class="line">从上文可以了解到EndPoint用于处理Socket，其中的Acceptor用于接收来自Server的请求。  </span><br><span class="line">  </span><br><span class="line">Acceptor不断监听Server端的请求，并将请求交给Processor(用于将Endpoint接收到的Socket封装成Request)</span><br></pre></td></tr></table></figure>
//org.apache.tomcat.util.net.NioEndpoint.Acceptor<br>protected class Acceptor extends AbstractEndpoint.Acceptor {<pre><code>@Override
public void run() {
    int errorDelay = 0;
    while (running) {
        ......
        try {
            SocketChannel socket = null;
            try {
                // 接受来自Server的下一个请求，封装成socket
                socket = serverSock.accept();
            } catch (IOException ioe) {......}
            }
            ......
            if (running &amp;&amp; !paused) {
                // 通过setSocketOptions()将socket交给Processor
                if (!setSocketOptions(socket)) {
                    closeSocket(socket);
                }
            } else {
                closeSocket(socket);
            }
        } catch (Throwable t) {......}
    }
    ......
}
......</code></pre>  }<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">setSocketOptions将socket注册到Poller线程进行轮询并交给Processor：  </span><br><span class="line">  </span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line">&#x2F;&#x2F;org.apache.tomcat.util.net.NioEndpoint.Acceptor</span><br><span class="line">protected boolean setSocketOptions(SocketChannel socket) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F;disable blocking</span><br><span class="line">        socket.configureBlocking(false);</span><br><span class="line">        Socket sock &#x3D; socket.socket();</span><br><span class="line">        &#x2F;&#x2F; setProperties具体实现是在org.apache.tomcat.util.net.socketProperties，该方法设置了socket的一些属性如BufferSize、KeepAlive、Timeout等</span><br><span class="line">        socketProperties.setProperties(sock);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 根据socket中的BufSize创建channel</span><br><span class="line">        NioChannel channel &#x3D; nioChannels.pop();</span><br><span class="line">        if (channel &#x3D;&#x3D; null) &#123;</span><br><span class="line">            SocketBufferHandler bufhandler &#x3D; new SocketBufferHandler(</span><br><span class="line">                    socketProperties.getAppReadBufSize(),</span><br><span class="line">                    socketProperties.getAppWriteBufSize(),</span><br><span class="line">                    socketProperties.getDirectBuffer());</span><br><span class="line">            if (isSSLEnabled()) &#123;......&#125; </span><br><span class="line">            else &#123;</span><br><span class="line">                channel &#x3D; new NioChannel(socket, bufhandler);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;......&#125;</span><br><span class="line">        &#x2F;&#x2F; 将chanel注册到Poller线程，进行轮询，在org.apache.tomcat.util.net.NioEndpoint.Poller中转交给Processor</span><br><span class="line">        getPoller0().register(channel);</span><br><span class="line">    &#125; catch (Throwable t) &#123;......&#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
看一下Processor中的关键代码，携带Poller提交给Processor的channel转交给processSocket进行处理：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.apache.tomcat.util.net.NioEndpoint.Poller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Poller</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">......</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// attachment等同于承载了socket的channel</span></span><br><span class="line">        ......</span><br><span class="line">        NioSocketWrapper attachment = (NioSocketWrapper)sk.attachment();</span><br><span class="line">        processKey(sk, attachment)</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processKey</span><span class="params">(SelectionKey sk, NioSocketWrapper attachment)</span></span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 调用processSocket处理socket</span></span><br><span class="line">        processSocket(attachment, SocketEvent.OPEN_WRITE, <span class="keyword">true</span>)</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
我们看下此时的attachment，其中存在上文提到的Timeout、keepAlive等属性，并且封装了socket，在socket中可以看到所在的Channel以及本地服务端口8009和Server的端口51584。<br><img src="https://note.youdao.com/yws/res/2547/D451A0EF9BFA49F5922031F07873822C" alt="image"></li>
</ul>
<p>在processSocket方法中，将请求转交给了SocketProcessorBase，并调用SocketProcessorBase的run方法：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.apache.tomcat.util.net.AbstractEndpoint.processSocket</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">processSocket</span><span class="params">(SocketWrapperBase&lt;S&gt; socketWrapper, SocketEvent event, <span class="keyword">boolean</span> dispatch)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">        SocketProcessorBase&lt;S&gt; sc = processorCache.pop();</span><br><span class="line">        <span class="keyword">if</span> (sc == <span class="keyword">null</span>) &#123;</span><br><span class="line">            sc = createSocketProcessor(socketWrapper, event);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;......&#125;</span><br><span class="line">        ......</span><br><span class="line">        sc.run();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RejectedExecutionException ree) &#123;......&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.apache.tomcat.util.net.SocketProcessorBase</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketProcessorBase</span>&lt;<span class="title">S</span>&gt; <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        doRun();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>org.apache.tomcat.util.net.NioEndpoint.SocketProcessor</code>重写了SocketProcessor，并交给Handler中的process，这里的Handler就是AjpConnectionHandler，并在process中调用Processer处理请求。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.apache.tomcat.util.net.NioEndpoint.SocketProcessor</span></span><br><span class="line"><span class="keyword">protected</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketProcessor</span> <span class="keyword">extends</span> <span class="title">SocketProcessorBase</span>&lt;<span class="title">NioChannel</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SocketProcessor</span><span class="params">(SocketWrapperBase&lt;NioChannel&gt; socketWrapper, SocketEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(socketWrapper, event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// socketWrapper等同于attachment，从socketWrapper中获取socket</span></span><br><span class="line">        NioChannel socket = socketWrapper.getSocket();</span><br><span class="line">        <span class="comment">// socket中获取channel的key</span></span><br><span class="line">        SelectionKey key = socket.getIOChannel().keyFor(socket.getPoller().getSelector());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> handshake = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (key != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (socket.isHandshakeComplete()) &#123;</span><br><span class="line">                        <span class="comment">// 在这里将socket交给Handler</span></span><br><span class="line">                        handshake = <span class="number">0</span>;</span><br><span class="line">                    &#125; </span><br><span class="line">                    ......</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">            &#125; <span class="keyword">catch</span> (CancelledKeyException ckx) &#123;</span><br><span class="line">                handshake = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (handshake == <span class="number">0</span>) &#123;</span><br><span class="line">                SocketState state = SocketState.OPEN;</span><br><span class="line">                <span class="keyword">if</span> (event == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    ......</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 调用Handler中的process方法</span></span><br><span class="line">                    state = getHandler().process(socketWrapper, event);</span><br><span class="line">                &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;org.apache.tomcat.util.net.AbstractProtocol.ConnectionHandler.process</span><br><span class="line">public SocketState process(SocketWrapperBase&lt;S&gt; wrapper, SocketEvent status) &#123;</span><br><span class="line">    S socket &#x3D; wrapper.getSocket();</span><br><span class="line">    &#x2F;&#x2F; 实例化processor，此时processor为null</span><br><span class="line">    Processor processor &#x3D; connections.get(socket);</span><br><span class="line">    &#x2F;&#x2F; 从队列中获取processor</span><br><span class="line">    processor &#x3D; recycledProcessors.pop();</span><br><span class="line">    &#x2F;&#x2F; 更新processor的状态（状态默认为CLOSED）</span><br><span class="line">    state &#x3D; processor.process(wrapper, status);</span><br></pre></td></tr></table></figure>
<p>上面代码中的processor.process()会设置processor状态为open，并对socket内容进行解析，包括protocol、requestURI、remoteAddr、remoteHost、Headers以及本漏洞的重点attributes。<br>解析attributes的代码如下，通过循环取出attributes中的所有attribute，并解析其name和value：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.coyote.ajp.AjpProcessor.prepareRequest</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">prepareRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">while</span> ((attributeCode = requestHeaderMessage.getByte()) != Constants.SC_A_ARE_DONE) &#123;</span><br><span class="line">        <span class="comment">// 判断是否包含attributes，并对attributeCode内容进行解析</span></span><br><span class="line">        <span class="keyword">switch</span> (attributeCode) &#123;</span><br><span class="line">        <span class="keyword">case</span> Constants.SC_A_REQ_ATTRIBUTE :</span><br><span class="line">            <span class="comment">// 解析attributes中的name</span></span><br><span class="line">            requestHeaderMessage.getBytes(tmpMB);</span><br><span class="line">            String n = tmpMB.toString();</span><br><span class="line">            <span class="comment">// 解析attributes中的value</span></span><br><span class="line">            requestHeaderMessage.getBytes(tmpMB);</span><br><span class="line">            String v = tmpMB.toString();</span><br><span class="line">            ......</span><br><span class="line">            <span class="comment">// 将attribute添加到request中</span></span><br><span class="line">            request.setAttribute(n, v );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经过Processer解析后的request数据如下，包含了通过AJP提交的所有数据：<br><img src="https://note.youdao.com/yws/res/2725/D7364EE348FA43FBA5651C00DF553FAE" alt="image"><br>在<code>org.apache.coyote.ajp.AjpProcessor.prepareRequest.SocketState</code>中将request数据提交给adapter。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;org.apache.coyote.ajp.AjpProcessor.prepareRequest.SocketState</span><br><span class="line">public SocketState service(SocketWrapperBase&lt;?&gt; socket) throws IOException &#123;</span><br><span class="line">    ......</span><br><span class="line">    getAdapter().service(request, response);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在adapter中的service方法将获取Container的Pipeline对request进行处理。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line">public void service(org.apache.coyote.Request req, org.apache.coyote.Response res) throws Exception &#123;</span><br><span class="line">......</span><br><span class="line">    &#x2F;&#x2F; 设置scheme，serverName,port,sessionId等</span><br><span class="line">    postParseSuccess &#x3D; postParseRequest(req, request, res, response);</span><br><span class="line">        if (postParseSuccess) &#123;</span><br><span class="line">            ......</span><br><span class="line">            &#x2F;&#x2F; call container来处理请求</span><br><span class="line">            connector.getService().getContainer().getPipeline().getFirst().invoke(request, response);</span><br><span class="line">        &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line">&#96;&#96;&#96;  </span><br><span class="line">参考2中描述了Container的结构：  </span><br><span class="line">![image](https:&#x2F;&#x2F;note.youdao.com&#x2F;yws&#x2F;res&#x2F;2786&#x2F;0736BDFB5550430DBCA4C3E8FC061321)  </span><br><span class="line"></span><br><span class="line">可见Container包含Engine、Host、Context和Wrapper四个容器，分别对应各自的Pipeline，对应的实现类在&#96;org.apache.catalina.core&#96;中：  </span><br><span class="line">- Engine：用来管理host，寻找host，并将request交给host；</span><br><span class="line">- Host：Host为Container中的虚拟主机，负责设置context；</span><br><span class="line">- Context：Context为Host中的应用，对应WEB-INF目录，负责寻找wrapper；</span><br><span class="line">- Wrapper：Servlet封装在Weapper中。  </span><br><span class="line"></span><br><span class="line">此处列举代码执行流程：</span><br><span class="line">Engine寻找Host并将request提交给Host，这里本机环境的Host为localhost：  </span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line">&#x2F;&#x2F;org.apache.catalina.core.StandardEngineValue</span><br><span class="line">public final void invoke(Request request, Response response)&#123;</span><br><span class="line">    ......</span><br><span class="line">    &#x2F;&#x2F; 查找并获取Host</span><br><span class="line">    Host host &#x3D; request.getHost();</span><br><span class="line">    &#x2F;&#x2F; 请求host处理这个request</span><br><span class="line">    host.getPipeline().getFirst().invoke(request, response);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line">&#96;&#96;&#96;  </span><br><span class="line">Host寻找Context并将request提交给Context：  </span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line">&#x2F;&#x2F;org.apache.catalina.core.StandardHostValue</span><br><span class="line">public final void invoke(Request request, Response response) throws IOException, ServletException &#123;</span><br><span class="line">    ......</span><br><span class="line">    &#x2F;&#x2F; 查找并获取Host</span><br><span class="line">    Context context &#x3D; request.getContext();</span><br><span class="line">    &#x2F;&#x2F; 请求Context处理这个request</span><br><span class="line">    context.getPipeline().getFirst().invoke(request, response);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line">&#96;&#96;&#96;  </span><br><span class="line">Context中将request交给Wrapper：  </span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line">&#x2F;&#x2F;org.apache.catalina.core.StandardContextValue</span><br><span class="line">public final void invoke(Request request, Response response) throws IOException, ServletException &#123;</span><br><span class="line">    ......</span><br><span class="line">    &#x2F;&#x2F; 获取request中的path，这里path必须在WEB-INF或META-INF目录下</span><br><span class="line">    MessageBytes requestPathMB &#x3D; request.getRequestPathMB()</span><br><span class="line">    &#x2F;&#x2F; 禁止直接访问WEB-INF或META-INF下的资源</span><br><span class="line">    if ((requestPathMB.startsWithIgnoreCase(&quot;&#x2F;META-INF&#x2F;&quot;, 0))</span><br><span class="line">                || (requestPathMB.equalsIgnoreCase(&quot;&#x2F;META-INF&quot;))</span><br><span class="line">                || (requestPathMB.startsWithIgnoreCase(&quot;&#x2F;WEB-INF&#x2F;&quot;, 0))</span><br><span class="line">                || (requestPathMB.equalsIgnoreCase(&quot;&#x2F;WEB-INF&quot;))) &#123;</span><br><span class="line">            response.sendError(HttpServletResponse.SC_NOT_FOUND);</span><br><span class="line">            return;</span><br><span class="line">    &#x2F;&#x2F; 获取Wrapper并将Request交给Wrapper</span><br><span class="line">    Wrapper wrapper &#x3D; request.getWrapper();</span><br><span class="line">    wrapper.getPipeline().getFirst().invoke(request, response);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line">&#96;&#96;&#96;  </span><br><span class="line">Wrapper中为reqeust创建了一个过滤器，主要用于检查一些字符是否安全：  </span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line">&#x2F;&#x2F;org.apache.catalina.core.StandardWrapperValue</span><br><span class="line">public final void invoke(Request request, Response response) throws IOException, ServletException &#123;</span><br><span class="line">    ......</span><br><span class="line">    &#x2F;&#x2F; 创建wrapper实例</span><br><span class="line">    StandardWrapper wrapper &#x3D; (StandardWrapper) getContainer();</span><br><span class="line">    &#x2F;&#x2F; 获取reqeust中的请求路径，并设置到属性中</span><br><span class="line">    MessageBytes requestPathMB &#x3D; request.getRequestPathMB();</span><br><span class="line">    request.setAttribute(Globals.DISPATCHER_REQUEST_PATH_ATTR, requestPathMB);</span><br><span class="line">    &#x2F;&#x2F; 为这个request创建一个filterChain，在filterChain中设置了servlet</span><br><span class="line">    ApplicationFilterChain filterChain &#x3D; ApplicationFilterFactory.createFilterChain(request, wrapper, servlet);</span><br><span class="line">    filterChain.doFilter(request.getRequest(), response.getResponse());</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line">&#96;&#96;&#96;  </span><br><span class="line">在doFilter方法中，调用&#96;javax.servlet.http&#96;中的service方法对request进行处理，这里根据URI中的文件路径进行判断，若为JSP则走到&#96;org.apache.jasper.servlet.JspServlet&#96;造成jsp文件包含，否则走到&#96;org.apache.catalina.DefaultServlet&#96;造成任意文件读取：  </span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line">&#x2F;&#x2F;org.apache.catalina.core.ApplicationFilterChain</span><br><span class="line">private void internalDoFilter(ServletRequest request, ServletResponse response) throws IOException, ServletException &#123;</span><br><span class="line">    if ((request instanceof HttpServletRequest) &amp;&amp; (response instanceof HttpServletResponse) &amp;&amp; Globals.IS_SECURITY_ENABLED ) &#123;</span><br><span class="line">        ......</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            servlet.service(request, response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#96;&#96;&#96;  </span><br><span class="line">先看下任意文件读取漏洞：  </span><br><span class="line"></span><br><span class="line">经过&#96;org.apache.catalina.DefaultServlet.service&#96;，获取了request中的所有数据包括Method、URI、attributes等。  </span><br><span class="line">代码之后走到了&#96;org.apache.catalina.DefaultServlet.serveResource&#96;，并通过&#96;String path &#x3D; getRelativePath(request, true);&#96;从attributes中获取servletPath和pathinfo，并返回&#96;servletPath + pathInfo + &#x2F;&#96;的字符串：  </span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line">&#x2F;&#x2F;org.apache.catalina.DefaultServlet.getRelativePath</span><br><span class="line">protected String getRelativePath(HttpServletRequest request, boolean allowEmptyPath) &#123;</span><br><span class="line">    String servletPath;</span><br><span class="line">    String pathInfo;</span><br><span class="line">    if (request.getAttribute(RequestDispatcher.INCLUDE_REQUEST_URI) !&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; 在attribute中查找path_info并赋值</span><br><span class="line">        pathInfo &#x3D; (String)</span><br><span class="line">        request.getAttribute(RequestDispatcher.INCLUDE_PATH_INFO);</span><br><span class="line">        &#x2F;&#x2F; 在attribute中查找servlet_path并赋值</span><br><span class="line">        servletPath &#x3D; (String) request.getAttribute(RequestDispatcher.INCLUDE_SERVLET_PATH);</span><br><span class="line">    else&#123;......&#125;</span><br><span class="line">    StringBuilder result &#x3D; new StringBuilder();</span><br><span class="line">    &#x2F;&#x2F; 将servletPath和pathInfo进行拼接，格式为servletPath + pathInfo + &#x2F;</span><br><span class="line">    if (servletPath.length() &gt; 0) &#123;</span><br><span class="line">        result.append(servletPath);</span><br><span class="line">    &#125;</span><br><span class="line">    if (pathInfo !&#x3D; null) &#123;</span><br><span class="line">        result.append(pathInfo);</span><br><span class="line">    &#125;</span><br><span class="line">    if (result.length() &#x3D;&#x3D; 0 &amp;&amp; !allowEmptyPath) &#123;</span><br><span class="line">        result.append(&#39;&#x2F;&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">    return result.toString();</span><br><span class="line">&#125;</span><br><span class="line">&#96;&#96;&#96;  </span><br><span class="line">继续看&#96;org.apache.catalina.DefaultServlet.serveResource&#96;，在获取到完整path路径后，会通过getResource获取文件，并且获取文件的过程没有任何过滤措施。</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line">&#x2F;&#x2F;org.apache.catalina.DefaultServlet.serveResource</span><br><span class="line">protected void serveResource(HttpServletRequest request, HttpServletResponse response, boolean content, String inputEncoding) throws IOException, ServletException &#123;</span><br><span class="line">    ......</span><br><span class="line">    boolean serveContent &#x3D; content;</span><br><span class="line">    &#x2F;&#x2F;在这里获取servletPath和pathinfo，</span><br><span class="line">    String path &#x3D; getRelativePath(request, true);</span><br><span class="line">    WebResource resource &#x3D; resources.getResource(path);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line">&#96;&#96;&#96;  </span><br><span class="line">&#96;getResource&#96;方法会对通过&#96;org.apache.cataline.webresources.StandardRoot&#96;对path进行过滤，若path不是以&#39;&#x2F;&#39;开头将返回500错误，所以本漏洞只能够包含项目根目录下的所有文件。</span><br></pre></td></tr></table></figure>
<p>//org.apache.cataline.webresources.StandardRoot<br>private String validate(String path) {<br>    if (path == null || path.length() == 0 || !path.startsWith(“/“)) {<br>            throw new IllegalArgumentException(<br>                    sm.getString(“standardRoot.invalidPath”, path));<br>        }<br>    ……</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">接&#96;org.apache.catalina.DefaultServlet.serveResource&#96;的代码，在获取到文件后，设置response头部并将序列化的文件内容装入response。之后经过Context -&gt; Host -&gt; Engine -&gt; Connector将文件返回给Server。至此完成任意文件读取。</span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line">&#x2F;&#x2F;org.apache.catalina.DefaultServlet.serveResource</span><br><span class="line">protected void serveResource(HttpServletRequest request, HttpServletResponse response, boolean content, String inputEncoding) throws IOException, ServletException &#123;</span><br><span class="line">    ......</span><br><span class="line">    WebResource resource &#x3D; resources.getResource(path);</span><br><span class="line">    String contentType &#x3D; resource.getMimeType();</span><br><span class="line">    &#x2F;&#x2F; 这里省略的代码用于准备response，对返回的文件类型或名称没有做过滤（设置response的头部</span><br><span class="line">    ......</span><br><span class="line">    &#x2F;&#x2F; 这里省略的代码用于序列化文件内容</span><br><span class="line">    ......</span><br><span class="line">    ServletOutputStream ostream &#x3D; null;</span><br><span class="line">    ostream &#x3D; response.getOutputStream();</span><br><span class="line">    OutputStreamWriter osw &#x3D; new OutputStreamWriter(ostream, charset);</span><br><span class="line">    ......</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>读取ROOT/WEB-INF/web.xml：<br><img src="https://note.youdao.com/yws/res/3121/B504C16A52D74EE0A042541356EBED0B" alt="image"></p>
<p>JSP文件包含漏洞与上面类似，若AJP请求中的URI包含jsp，则单独使用jspServlet<code>org.apache.jasper.servlet.JspServlet</code>来处理。从下面的代码可以看到JspServlet同样会获取attributes，并在<code>serviceJspFile</code>方法对jsp文件进行编译：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.apache.jasper.servlet.JspServlet</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span> <span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 获取servlet path</span></span><br><span class="line">    jspUri = (String) request.getAttribute(RequestDispatcher.INCLUDE_SERVLET_PATH);</span><br><span class="line">    <span class="comment">// 获取path</span></span><br><span class="line">    String pathInfo = (String) request.getAttribute(RequestDispatcher.INCLUDE_PATH_INFO);</span><br><span class="line">    <span class="comment">// 组装成完成的jsp路径</span></span><br><span class="line">    jspUri += pathInfo</span><br><span class="line">    serviceJspFile(request, response, jspUri, precompile);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;org.apache.jasper.servlet.JspServlet</span><br><span class="line">private void serviceJspFile(HttpServletRequest request, HttpServletResponse response, String jspUri, boolean precompile) throws ServletException, IOException &#123;</span><br><span class="line">    ......</span><br><span class="line">    &#x2F;&#x2F;对jsp文件进行编译</span><br><span class="line">    boolean precompile &#x3D; preCompile(request);</span><br><span class="line">    serviceJspFile(request, response, jspUri, precompile);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后续的编译过程和response的代码不再详述，至此完成jsp文件包含。<br>包含/ROOT/目录下的test_jsp.tt，打印”hello world”，若tomcat存在文件上传，能够利用此漏洞执行远程命令。<br><img src="https://note.youdao.com/yws/res/3173/C641462F5FA845E99A21B68B9D5921CD" alt="image"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://blog.csdn.net/it_freshman/article/details/81710793" target="_blank" rel="noopener">https://blog.csdn.net/it_freshman/article/details/81710793</a></li>
<li><a href="https://www.infoq.cn/article/zh-tomcat-http-request-1/" target="_blank" rel="noopener">https://www.infoq.cn/article/zh-tomcat-http-request-1/</a></li>
</ol>

  </div>
</article>



    </div>
    
      <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/posts/">Writing</a></li>
         
          <li><a href="http://github.com/sergodeeva" target="_blank" rel="noopener">Projects</a></li>
         
          <li><a href="/URL">LINK_NAME</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Tomcat初始化过程"><span class="toc-number">1.</span> <span class="toc-text">Tomcat初始化过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Connector的初始化流程"><span class="toc-number">1.1.</span> <span class="toc-text">Connector的初始化流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DEBUG-CVE-2020-1938"><span class="toc-number">2.</span> <span class="toc-text">DEBUG CVE-2020-1938</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-number">3.</span> <span class="toc-text">参考</span></a></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://homerqing.github.io/2020/04/10/tomat/CVE-2020-1938%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90/" target="_blank" rel="noopener"><i class="fa fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://homerqing.github.io/2020/04/10/tomat/CVE-2020-1938%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90/&text=tomat/CVE-2020-1938深度分析" target="_blank" rel="noopener"><i class="fa fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://homerqing.github.io/2020/04/10/tomat/CVE-2020-1938%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90/&title=tomat/CVE-2020-1938深度分析" target="_blank" rel="noopener"><i class="fa fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://homerqing.github.io/2020/04/10/tomat/CVE-2020-1938%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90/&is_video=false&description=tomat/CVE-2020-1938深度分析" target="_blank" rel="noopener"><i class="fa fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=tomat/CVE-2020-1938深度分析&body=Check out this article: http://homerqing.github.io/2020/04/10/tomat/CVE-2020-1938%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90/"><i class="fa fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://homerqing.github.io/2020/04/10/tomat/CVE-2020-1938%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90/&title=tomat/CVE-2020-1938深度分析" target="_blank" rel="noopener"><i class="fa fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://homerqing.github.io/2020/04/10/tomat/CVE-2020-1938%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90/&title=tomat/CVE-2020-1938深度分析" target="_blank" rel="noopener"><i class="fa fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://homerqing.github.io/2020/04/10/tomat/CVE-2020-1938%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90/&title=tomat/CVE-2020-1938深度分析" target="_blank" rel="noopener"><i class="fa fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://homerqing.github.io/2020/04/10/tomat/CVE-2020-1938%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90/&title=tomat/CVE-2020-1938深度分析" target="_blank" rel="noopener"><i class="fa fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://homerqing.github.io/2020/04/10/tomat/CVE-2020-1938%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90/&name=tomat/CVE-2020-1938深度分析&description=" target="_blank" rel="noopener"><i class="fa fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
      <ul>
        <li id="toc"><a class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa fa-list fa-lg" aria-hidden="true"></i> TOC</a></li>
        <li id="share"><a class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa fa-share-alt fa-lg" aria-hidden="true"></i> Share</a></li>
        <li id="top" style="display:none"><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a></li>
        <li id="menu"><a class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa fa-bars fa-lg" aria-hidden="true"></i> Menu</a></li>
      </ul>
    </div>

  </div>
</div>

    
    <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2020 Homer
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/posts/">Writing</a></li>
         
          <li><a href="http://github.com/sergodeeva" target="_blank" rel="noopener">Projects</a></li>
         
          <li><a href="/URL">LINK_NAME</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

</body>
</html>
<!-- styles -->

<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<link rel="stylesheet" href="/lib/meslo-LG/styles.css">


<link rel="stylesheet" href="/lib/justified-gallery/justifiedGallery.min.css">


<!-- jquery -->

<script src="/lib/jquery/jquery.min.js"></script>


<script src="/lib/justified-gallery/jquery.justifiedGallery.min.js"></script>


<script src="/js/main.js"></script>



    <!-- Google Analytics -->
    <script type="text/javascript">
        (function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-37473492-6', 'auto');
        ga('send', 'pageview');
    </script>



